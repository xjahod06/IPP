# Interpret
## Návrh
Program prvně pomocí knihovny `argparse` rozpozná argumenty spouštění programu, poté se pomocí knihovny `xml.etree.ElementTree` rozparsuje XML na namespace. Následně už rozparsované XML projde třemi cykly, kdy první kontroluje, jestli u následných instrukcí existují atributy `order` a `opcode`, které jsou nezbytné pro běh programu. Druhý cyklus načte pozici instrukcí definující návěstí `LABEL`, kontroluje duplicitu `order` a jeho nezápornost. Třetí cyklus už provádí samotné instrukce pomocí cyklu while, aby se dalo skočit z jedné instrukce na druhou pomocí změny čítače cyklu.
###Implementace
Argumenty programu a jejich rozlišení řídí knihovna `argparse`, následně se pouze kontroluje, jestli byla zadána alespoň jedna z možností `--source=`, `--input=`. Dál se pokračuje na parsování XML přes knihovnu `xml.etree.ElementTree`, kde se přes try: odchytávají vyjímky `ET.ParseError` a `FileNotFoundError`. Následně se inicializují jednotlivé framy jako slovníky a poprvé se projde parsované XML. Při tomto průchodu se testuje existence atributů `order` a `opcode` pomocí try: před odchytáváním vyjímky `KeyError` a zároveň je-li obsah atributu `order` číslo. Poté se přes fuknci `sorted` s využitím parametru key přes lambda funkci se seřadí instrukce dle atributu `order`. Následně přichází druhý průchod, kde se kontroluje atribut instrukcí `order`, jestli je kladný a unikátní, a zapisuje se pořadí jednotlivých návěstí instukcí `LABEL` a kontroluje se jejich originalita.
Následně se přejde do Hlavního cyklu while, který jednotlivé instrukce provádí. Podle `opcode` se určí, jaká instrukce se má provádět. Každá instrukce se prvně kontroluje, jestli má tag instruction, správný počet arg tag argumentu a u nich správné atributy. Poté se podle typu argumentu určí co se s ním má dělat.
Proměnná se pomocí funkce `split` rozdělí na rámec a název proměnné, poté se dle prováděné instrukce testuje, jestli dané jméno existuje ve framu, případně dle instrukce jestli je dané proměnná v rámci inicializovaná. Zavedení proměnné do rámce se provádí vložením na dané jméno objekt `value_of_var`, který si drží v sobě uloženou hodnotu a typ. Samotná inicializace proměnné se pozná, pokud má daný objekt svůj typ None, nebo ne. Při inicializaci proměnné se zároveň provádí převod jednotlivých datových typů. U datového typu `string` se překlad escape sequenci řeší pomocí knihovny `re` (RegEx), kde se jednotlivá hodnota nahradí pomocí funkce `chr()`. U datových typů `int` a `float` se odchytává vyjímka `ValueError` pro případ vložení nevalidní hodnoty. Ostatní datové typy argumentu (string, int, float, bool, nil) se pro zjednodušení práce taky převedou na objekt `value_of_var`, ale neukládají se do žádného rámce.
Správa rámců funguje na principu slovníků (`dict()`), kde global frame je určen jako jeden neměnný slovník. Tempolary frame je definován jako jeden slovník s proměnnou, která určuje jestli se vyskytujeme v rámci nebo ne (jestli má TF existovat), tempolary frame vzniká s instrukcí `CREATEFRAME` a zaniká instrukcí `PUSHFRAME`, kdy se z něj stává locale frame, nebo další instrukcí `CREATEFRAME`. Local frame je definován zároveň se zásobníkem rámců a to jako poslední vložený rámec na zásobník, takže kontrola toho jestli existuje či nikoliv se odvíjí od délky zásobníku rámců.
Všechny skokové instrukce pracují se slovníkem známých návěstí, který obsahuje název návěstí a jeho pořadí mezi prováděnými instrukcemi, toto pořadí se poté uloží do počítače cyklu while. Instrukce `CALL` a `RETURN` navíc pracují se zásobníkem skoků, kde je uloženo odkud byl skok proveden. Pro zjednodušení běhu programu jsem některé instrukce které pracují podobně sdružil do stejných funkcí, jinak většina instrukcí má svoji vlastní funkci.

# Test
## Návrh a Implementace
program je určen na testování scriptů `interpret.py` a `parse.php` podle přiložených testů a následnou generaci výstupního HTML pro přehlednou kontrolu funkčnosti scriptů. Kontrola správnosti XML u `parse-only` testů se provádí přes nástroj `A7Soft JExamXML`, u testů `int-only` se porovnávání výsledků provádí přes linuxový nástroj `diff`. Pro nalezení cesty k testovým souborům se používá příkz find s využitím RegEx na nalezení souborů `(.*?)([^\/]*(?=\.src))`. Po nalezení jednotlivých souborů se pomocí RegEx rozdělí celé jméno na jméno souboru a cestu, kde se po každém projití scriptem vytvoří dočasný soubor, který potom jde buď do dalšího scriptu nebo se porovnává s testovacím výstupem jedním z nástrojů. Výsledek testů se poté ukládá jako objekt `test`, který je vložen do pole testů, pokud test skončil jako rozdíl výstupních souborů, tak se jejich rozdíl uloží do slovníku pro budoucí využití při generaci HTML. Při samotném generování HTML se berou testy z pole testů a vkládají se pod sebe do tabulky, pokud se změní cesta k danému souboru, tak se vytiskne  prázdný řádek tabulky s názvem složky pro lepší rozlišení. Pokud test skončil chybovým kódem tak se zobrazí v tabulce spolu s očekávaným kódem, pokud ale test skončí rozdílem na výstupu, tak se daný výstup po kliknutí na jméno testu, zobrazí na spodní straně HTML stránky. Pomocí Javasriptu je nad tabulkou ještě udělána základní filtrace, ale pouze na možnost vypnout a zapnout některé kategorie testů.